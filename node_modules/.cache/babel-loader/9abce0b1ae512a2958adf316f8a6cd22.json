{"ast":null,"code":"var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar dest_row, dest_col;\nvar unvisitedNodes = [];\nexport function astar(grid, start_node, end_node) {\n  unvisitedNodes = getAllNodes(grid);\n  start_node.distance = 0;\n\n  while (unvisitedNodes.length !== 0) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    closestNode.isVisited = true;\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === 1000000000) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === end_node) return visitedNodesInOrder;\n    updateNeighbors(closestNode, grid);\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction get_euclid_distance(x1, y1, x2, y2) {\n  var v1 = Math.pow(x1 - x2, 2);\n  v1 = v1 * v1;\n  var v2 = Math.pow(y1 - y2, 2);\n  v2 = v2 * v2;\n  return Math.pow(v1 + v2, 0.5);\n}\n/* this is our sor function, the place where A* differs from dijkstra's\n Here we sort based on a function f=g+h, where,\n g - distance with which we reach the neighbor node\n h - the heurestic/ prediction/ possible amount of moves to reach target\n this heurestic can be say euclidean distance, or manhattan distance etc\n*/\n\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => {\n    return nodeA.distance + get_euclid_distance(nodeA.row, nodeA.col, dest_row, dest_col) - (nodeB.distance + get_euclid_distance(nodeB.row, nodeB.col, dest_row, dest_col));\n  });\n}\n\nfunction updateNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const nodes of unvisitedNeighbors) {\n    nodes.distance = node.distance + 1;\n    nodes.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); //We are only concerned about the unvisited neighbors\n\n  return neighbors.filter(node => !node.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n\n  return nodes;\n}\n\nexport function solve_astar(grid, start_node, end_node) {\n  visitedNodesInOrder = [];\n  nodesInShortestPathOrder = [];\n  dest_row = end_node.row;\n  dest_col = end_node.col;\n  return astar(grid, start_node, end_node);\n} // Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n\nexport function getNodesInShortestPathOrderASTAR(finishNode) {\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/home/jagruth/Documents/path finding/src/Algorithm/ASearch.js"],"names":["visitedNodesInOrder","nodesInShortestPathOrder","dest_row","dest_col","unvisitedNodes","astar","grid","start_node","end_node","getAllNodes","distance","length","sortNodesByDistance","closestNode","shift","isVisited","isWall","push","updateNeighbors","get_euclid_distance","x1","y1","x2","y2","v1","Math","pow","v2","sort","nodeA","nodeB","row","col","node","unvisitedNeighbors","getUnvisitedNeighbors","nodes","previousNode","neighbors","filter","solve_astar","getNodesInShortestPathOrderASTAR","finishNode","currentNode","unshift"],"mappings":"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","sourcesContent":["var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar dest_row, dest_col;\nvar unvisitedNodes = [];\n\nexport function astar(grid, start_node, end_node) {\n\n  unvisitedNodes = getAllNodes(grid);\n  start_node.distance = 0;\n\n  while (unvisitedNodes.length !== 0) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    closestNode.isVisited = true;\n    if (closestNode.isWall) continue;\n    if (closestNode.distance === 1000000000) return visitedNodesInOrder;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === end_node) return visitedNodesInOrder;\n\n    updateNeighbors(closestNode, grid);\n  }\n  return visitedNodesInOrder;\n}\n\nfunction get_euclid_distance(x1, y1, x2, y2) {\n  var v1 = Math.pow(x1 - x2, 2);\n  v1 = v1 * v1;\n  var v2 = Math.pow(y1 - y2, 2);\n  v2 = v2 * v2;\n  return Math.pow(v1 + v2, 0.5);\n\n}\n\n/* this is our sor function, the place where A* differs from dijkstra's\n Here we sort based on a function f=g+h, where,\n g - distance with which we reach the neighbor node\n h - the heurestic/ prediction/ possible amount of moves to reach target\n this heurestic can be say euclidean distance, or manhattan distance etc\n*/\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => {\n    return (\n      nodeA.distance +\n      get_euclid_distance(nodeA.row, nodeA.col, dest_row, dest_col) -\n      (nodeB.distance +\n        get_euclid_distance(nodeB.row, nodeB.col, dest_row, dest_col))\n    );\n  });\n}\n\nfunction updateNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const nodes of unvisitedNeighbors) {\n    nodes.distance = node.distance + 1;\n    nodes.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n\n  //We are only concerned about the unvisited neighbors\n  return neighbors.filter((node) => !node.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nexport function solve_astar(grid, start_node, end_node) {\n  visitedNodesInOrder = [];\n  nodesInShortestPathOrder = [];\n  dest_row = end_node.row;\n  dest_col = end_node.col;\n  return astar(grid, start_node, end_node);\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrderASTAR(finishNode) {\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\nÂ "]},"metadata":{},"sourceType":"module"}