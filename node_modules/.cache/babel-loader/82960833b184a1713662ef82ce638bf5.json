{"ast":null,"code":"var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar dest_row, dest_col;\n\nfunction bfs(grid, row, col) {\n  const n = grid[row][col];\n  n.isVisited = true;\n  n.previousNode = null;\n  n.distance = 0;\n  var q = [];\n  q.push(n);\n\n  while (q.length > 0) {\n    var node = q.shift();\n    visitedNodesInOrder.push(node);\n    if (node.row === dest_row && node.col === dest_col) return;\n    var unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n    for (const to of unvisitedNeighbors) {\n      if (to.isWall) continue;\n\n      if (to.isVisited === false) {\n        q.push(to);\n        to.previousNode = node;\n        to.isVisited = true;\n        to.distance = node.distance + 1;\n      }\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]); //We are only concerned about the unvisited neighbors\n\n  return neighbors.filter(node => !node.isVisited);\n}\n\nexport function solve_bfs(grid, start_node, end_node) {\n  visitedNodesInOrder = [];\n  nodesInShortestPathOrder = [];\n  dest_row = end_node.row;\n  dest_col = end_node.col;\n  bfs(grid, start_node.row, start_node.col);\n  return visitedNodesInOrder;\n} // Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\n\nexport function getNodesInShortestPathOrderBFS(end_node) {\n  let currentNode = end_node;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/home/jagruth/Documents/path finding/src/Algorithm/BreadthFirstSearch.js"],"names":["visitedNodesInOrder","nodesInShortestPathOrder","dest_row","dest_col","bfs","grid","row","col","n","isVisited","previousNode","distance","q","push","length","node","shift","unvisitedNeighbors","getUnvisitedNeighbors","to","isWall","neighbors","filter","solve_bfs","start_node","end_node","getNodesInShortestPathOrderBFS","currentNode","unshift"],"mappings":"AAAA,IAAIA,mBAAmB,GAAG,EAA1B;AACA,IAAIC,wBAAwB,GAAG,EAA/B;AACA,IAAIC,QAAJ,EAAcC,QAAd;;AAEA,SAASC,GAAT,CAAaC,IAAb,EAAmBC,GAAnB,EAAwBC,GAAxB,EAA6B;AAC3B,QAAMC,CAAC,GAAGH,IAAI,CAACC,GAAD,CAAJ,CAAUC,GAAV,CAAV;AACAC,EAAAA,CAAC,CAACC,SAAF,GAAc,IAAd;AACAD,EAAAA,CAAC,CAACE,YAAF,GAAiB,IAAjB;AACAF,EAAAA,CAAC,CAACG,QAAF,GAAa,CAAb;AACA,MAAIC,CAAC,GAAG,EAAR;AACAA,EAAAA,CAAC,CAACC,IAAF,CAAOL,CAAP;;AAEA,SAAOI,CAAC,CAACE,MAAF,GAAW,CAAlB,EAAqB;AACnB,QAAIC,IAAI,GAAGH,CAAC,CAACI,KAAF,EAAX;AACAhB,IAAAA,mBAAmB,CAACa,IAApB,CAAyBE,IAAzB;AACA,QAAIA,IAAI,CAACT,GAAL,KAAaJ,QAAb,IAAyBa,IAAI,CAACR,GAAL,KAAaJ,QAA1C,EAAoD;AACpD,QAAIc,kBAAkB,GAAGC,qBAAqB,CAACH,IAAD,EAAOV,IAAP,CAA9C;;AACA,SAAK,MAAMc,EAAX,IAAiBF,kBAAjB,EAAqC;AACnC,UAAIE,EAAE,CAACC,MAAP,EAAe;;AACf,UAAID,EAAE,CAACV,SAAH,KAAiB,KAArB,EAA4B;AAC1BG,QAAAA,CAAC,CAACC,IAAF,CAAOM,EAAP;AACAA,QAAAA,EAAE,CAACT,YAAH,GAAkBK,IAAlB;AACAI,QAAAA,EAAE,CAACV,SAAH,GAAe,IAAf;AACAU,QAAAA,EAAE,CAACR,QAAH,GAAcI,IAAI,CAACJ,QAAL,GAAgB,CAA9B;AACD;AACF;AACF;AACF;;AAED,SAASO,qBAAT,CAA+BH,IAA/B,EAAqCV,IAArC,EAA2C;AACzC,QAAMgB,SAAS,GAAG,EAAlB;AACA,QAAM;AAAEf,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAeQ,IAArB;AAEA,MAAIT,GAAG,GAAG,CAAV,EAAae,SAAS,CAACR,IAAV,CAAeR,IAAI,CAACC,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAf;AACb,MAAIA,GAAG,GAAG,CAAV,EAAac,SAAS,CAACR,IAAV,CAAeR,IAAI,CAACC,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAf;AACb,MAAID,GAAG,GAAGD,IAAI,CAACS,MAAL,GAAc,CAAxB,EAA2BO,SAAS,CAACR,IAAV,CAAeR,IAAI,CAACC,GAAG,GAAG,CAAP,CAAJ,CAAcC,GAAd,CAAf;AAC3B,MAAIA,GAAG,GAAGF,IAAI,CAAC,CAAD,CAAJ,CAAQS,MAAR,GAAiB,CAA3B,EAA8BO,SAAS,CAACR,IAAV,CAAeR,IAAI,CAACC,GAAD,CAAJ,CAAUC,GAAG,GAAG,CAAhB,CAAf,EAPW,CAQzC;;AACA,SAAOc,SAAS,CAACC,MAAV,CAAkBP,IAAD,IAAU,CAACA,IAAI,CAACN,SAAjC,CAAP;AACD;;AAED,OAAO,SAASc,SAAT,CAAmBlB,IAAnB,EAAyBmB,UAAzB,EAAqCC,QAArC,EAA+C;AACpDzB,EAAAA,mBAAmB,GAAG,EAAtB;AACAC,EAAAA,wBAAwB,GAAG,EAA3B;AACAC,EAAAA,QAAQ,GAAGuB,QAAQ,CAACnB,GAApB;AACAH,EAAAA,QAAQ,GAAGsB,QAAQ,CAAClB,GAApB;AACAH,EAAAA,GAAG,CAACC,IAAD,EAAOmB,UAAU,CAAClB,GAAlB,EAAuBkB,UAAU,CAACjB,GAAlC,CAAH;AACA,SAAOP,mBAAP;AACD,C,CAED;AACA;;AACA,OAAO,SAAS0B,8BAAT,CAAwCD,QAAxC,EAAkD;AACvD,MAAIE,WAAW,GAAGF,QAAlB;;AACA,SAAOE,WAAW,KAAK,IAAvB,EAA6B;AAC3B1B,IAAAA,wBAAwB,CAAC2B,OAAzB,CAAiCD,WAAjC;AACAA,IAAAA,WAAW,GAAGA,WAAW,CAACjB,YAA1B;AACD;;AAED,SAAOT,wBAAP;AACD","sourcesContent":["var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar dest_row, dest_col;\n\nfunction bfs(grid, row, col) {\n  const n = grid[row][col];\n  n.isVisited = true;\n  n.previousNode = null;\n  n.distance = 0;\n  var q = [];\n  q.push(n);\n\n  while (q.length > 0) {\n    var node = q.shift();\n    visitedNodesInOrder.push(node);\n    if (node.row === dest_row && node.col === dest_col) return;\n    var unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n    for (const to of unvisitedNeighbors) {\n      if (to.isWall) continue;\n      if (to.isVisited === false) {\n        q.push(to);\n        to.previousNode = node;\n        to.isVisited = true;\n        to.distance = node.distance + 1;\n      }\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  //We are only concerned about the unvisited neighbors\n  return neighbors.filter((node) => !node.isVisited);\n}\n\nexport function solve_bfs(grid, start_node, end_node) {\n  visitedNodesInOrder = [];\n  nodesInShortestPathOrder = [];\n  dest_row = end_node.row;\n  dest_col = end_node.col;\n  bfs(grid, start_node.row, start_node.col);\n  return visitedNodesInOrder;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrderBFS(end_node) {\n  let currentNode = end_node;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}"]},"metadata":{},"sourceType":"module"}