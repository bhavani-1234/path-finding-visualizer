{"ast":null,"code":"var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar dest_row, dest_col;\nvar ok = 0;\nvar type = 1;\n\nfunction dfs(grid, row, col, par, d) {\n  const node = grid[row][col];\n  if (node.isWall) return;\n  visitedNodesInOrder.push(node);\n  node.isVisited = true;\n  node.previousNode = par;\n  node.distance = d;\n\n  if (row === dest_row && col === dest_col) {\n    nodesInShortestPathOrder.push(node);\n    ok = 1;\n    console.log(\"yes this happenned\");\n    return;\n  }\n\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const to of unvisitedNeighbors) {\n    if (to.isVisited === false) {\n      dfs(grid, to.row, to.col, node, d + 1);\n\n      if (ok) {\n        nodesInShortestPathOrder.push(node);\n        node.previousNode = par;\n        break;\n      }\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    row,\n    col\n  } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(node => !node.isVisited);\n}\n\nexport function solve_dfs(grid, start_node, end_node, t) {\n  visitedNodesInOrder = [];\n  nodesInShortestPathOrder = [];\n  ok = 0;\n  dest_row = end_node.row;\n  dest_col = end_node.col;\n  type = t;\n  dfs(grid, start_node.row, start_node.col, null, 0);\n  return visitedNodesInOrder;\n}\nexport function getNodesInShortestPathOrderDFS() {\n  nodesInShortestPathOrder.reverse();\n  return nodesInShortestPathOrder;\n}","map":{"version":3,"sources":["/home/jagruth/Documents/path finding/src/Algorithm/DepthFirstSearch.js"],"names":["visitedNodesInOrder","nodesInShortestPathOrder","dest_row","dest_col","ok","type","dfs","grid","row","col","par","d","node","isWall","push","isVisited","previousNode","distance","console","log","unvisitedNeighbors","getUnvisitedNeighbors","to","neighbors","length","filter","solve_dfs","start_node","end_node","t","getNodesInShortestPathOrderDFS","reverse"],"mappings":"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","sourcesContent":["var visitedNodesInOrder = [];\nvar nodesInShortestPathOrder = [];\nvar dest_row, dest_col;\nvar ok = 0;\nvar type = 1;\n\nfunction dfs(grid, row, col, par, d) {\n  const node = grid[row][col];\n  if (node.isWall) return;\n  visitedNodesInOrder.push(node);\n  node.isVisited = true;\n  node.previousNode = par;\n  node.distance = d;\n  \n  if (row === dest_row && col === dest_col) {\n    nodesInShortestPathOrder.push(node);\n    ok = 1;\n    console.log(\"yes this happenned\");\n    return;\n  }\n\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const to of unvisitedNeighbors) {\n    if (to.isVisited === false) {\n      dfs(grid, to.row, to.col, node, d + 1);\n      if (ok) {\n        nodesInShortestPathOrder.push(node);\n        node.previousNode = par;\n        break;\n      }\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  \n  return neighbors.filter((node) => !node.isVisited);\n}\n\nexport function solve_dfs(grid, start_node, end_node, t) {\n  visitedNodesInOrder = [];\n  nodesInShortestPathOrder = [];\n  ok = 0;\n  dest_row = end_node.row;\n  dest_col = end_node.col;\n  type = t;\n  dfs(grid, start_node.row, start_node.col, null, 0);\n  return visitedNodesInOrder;\n}\n\nexport function getNodesInShortestPathOrderDFS() {\n  nodesInShortestPathOrder.reverse();\n  return nodesInShortestPathOrder;\n}\n"]},"metadata":{},"sourceType":"module"}