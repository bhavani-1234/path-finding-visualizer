{"ast":null,"code":"var _jsxFileName = \"/home/jagruth/Documents/path finding/src/App.js\";\nimport React from \"react\";\nimport \"./App.css\";\nimport * as constants from \"./Constants\";\nimport NavBar from \"./Components/NavBar/NavBar\";\nimport Node from \"./Components/Node/Node\";\nimport { solve_algorithm } from \"./Algorithm/RootCaller\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nlet START_NODE_ROW = 12;\nlet START_NODE_COL = 30;\nlet END_NODE_ROW = 12;\nlet END_NODE_COL = 40;\nlet MID_NODE_ROW = -1;\nlet MID_NODE_COL = -1;\nconst N = 27;\nconst M = 75;\nlet cur_row = -1;\nlet cur_col = -1;\nlet algo = \"\";\nvar buttonPressed = constants.NONE;\nvar workIsDone = false;\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.do_mouse_work = (state_grid, row, col) => {\n      console.log(buttonPressed);\n\n      switch (buttonPressed) {\n        case constants.ADD_WALL:\n          {\n            add_wall_to_grid(state_grid, row, col);\n            break;\n          }\n\n        case constants.DEL_WALL:\n          {\n            del_wall_from_grid(state_grid, row, col);\n            break;\n          }\n\n        case constants.START:\n          {\n            console.log(\"ehere as well\");\n            change_start_node(state_grid, row, col);\n            break;\n          }\n\n        case constants.END:\n          {\n            change_end_node(state_grid, row, col);\n            break;\n          }\n\n        case constants.MID:\n          {\n            change_mid_node(state_grid, row, col);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      if (workIsDone === true) {\n        console.log(\"me\"); //if (this.state.grid[row][col].isWall) return;\n\n        this.visualizeAlgorithm(1, row, col, algo);\n      }\n    };\n\n    this.handleMouseDown = (row, col) => {\n      //if (row === cur_row && col === cur_col) return;\n      this.setState({\n        mouseIsPressed: true\n      });\n\n      if (this.state.grid[row][col].isStart) {\n        buttonPressed = constants.START;\n      } else if (this.state.grid[row][col].isEnd) {\n        buttonPressed = constants.END;\n      } else if (this.state.grid[row][col].isMid) {\n        buttonPressed = constants.MID;\n      } else if (this.state.grid[row][col].isWall) {\n        buttonPressed = constants.DEL_WALL;\n      } else {\n        buttonPressed = constants.ADD_WALL;\n      }\n\n      console.log(buttonPressed);\n      this.do_mouse_work(this.state.grid, row, col);\n      cur_row = row;\n      cur_col = col;\n    };\n\n    this.handleMouseEnter = (row, col) => {\n      //if (row === cur_row && col === cur_col) return;\n      if (!this.state.mouseIsPressed) return;\n      this.do_mouse_work(this.state.grid, row, col);\n      cur_row = row;\n      cur_col = col;\n    };\n\n    this.handleMouseUp = () => {\n      this.setState({\n        mouseIsPressed: false\n      });\n    };\n\n    this.handleChoice = ch => {\n      if (buttonPressed === ch) buttonPressed = constants.NONE;else buttonPressed = ch;\n      if (buttonPressed === constants.ADD_MID) add_mid_node(this.state.grid);else if (buttonPressed === constants.DEL_MID) del_mid_node(this.state.grid);\n    };\n\n    this.handleAlgorithm = (end_row, end_col, algo_type) => {\n      return solve_algorithm(this.state.grid, START_NODE_ROW, START_NODE_COL, END_NODE_ROW, END_NODE_COL, MID_NODE_ROW, MID_NODE_COL, algo_type);\n    };\n\n    this.visualizeAlgorithm = (type, row, col, algo_type) => {\n      workIsDone = true;\n      algo = algo_type;\n      if (type === 1) clear_all(this.state.grid);else clear_clever(this.state.grid);\n      const ret = this.handleAlgorithm(row, col, algo);\n      const visitedNodesInOrder = ret[0];\n      const nodesInShortestPathOrder = ret[1];\n      animateAlgorithm(this.state.grid, visitedNodesInOrder, nodesInShortestPathOrder, type); //if (buttonPressed !== constants.DONE) buttonPressed = constants.DONE;\n    };\n\n    this.clearBoard = () => {\n      const g = this.state.grid;\n      START_NODE_ROW = 1;\n      START_NODE_COL = 30;\n      END_NODE_ROW = 12;\n      END_NODE_COL = 40;\n      MID_NODE_ROW = MID_NODE_COL = cur_row = cur_col = -1;\n      buttonPressed = constants.NONE;\n      workIsDone = false;\n      this.setState({\n        mouseIsPressed: false\n      });\n\n      for (let i = 0; i < N; i++) {\n        for (let j = 0; j < M; j++) {\n          var node = g[i][j];\n          document.getElementById(`node-${i}-${j}`).className = \"node\";\n          node.row = i;\n          node.col = j;\n          node.isStart = node.row === START_NODE_ROW && node.col === START_NODE_COL;\n          node.isEnd = node.row === END_NODE_ROW && node.col === END_NODE_COL;\n          node.isMid = false;\n          node.isWall = false;\n          node.isVisited = false;\n          node.isVisited2 = false;\n          node.isShortest = false;\n          node.distance = 1000000000;\n          node.previousNode = null;\n          node.src = 0;\n        }\n\n        document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = \"node node_start\";\n        document.getElementById(`node-${END_NODE_ROW}-${END_NODE_COL}`).className = \"node node_end\";\n      }\n\n      this.setState({\n        grid: g\n      });\n    };\n\n    this.state = {\n      grid: [],\n      mouseIsPressed: false\n    };\n  }\n\n  componentDidMount() {\n    const g = initialiseGrid();\n    this.setState({\n      grid: g\n    });\n  }\n\n  render() {\n    const {\n      grid,\n      mouseIsPressed,\n      buttonPressed\n    } = this.state;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(NavBar, {\n      clearBoard: this.clearBoard,\n      handleChoice: this.handleChoice,\n      visualizeAlgorithm: this.visualizeAlgorithm,\n      end_node_row: END_NODE_ROW,\n      end_node_col: END_NODE_COL,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 191,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 9\n      }\n    }, grid.map((row, rowIdx) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowIdx,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 202,\n          columnNumber: 15\n        }\n      }, row.map((node, nodeIdx) => {\n        const {\n          row,\n          col,\n          isEnd,\n          isStart,\n          isWall,\n          isVisited,\n          isVisited2,\n          isMid,\n          isShortest\n        } = node;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: nodeIdx,\n          onMouseDown: (row, col) => this.handleMouseDown(row, col),\n          onMouseEnter: (row, col) => this.handleMouseEnter(row, col),\n          onMouseUp: () => this.handleMouseUp(),\n          onMouseClick: (row, col) => this.handleMouseClick(row, col),\n          row: row,\n          col: col,\n          isWall: isWall,\n          isStart: isStart,\n          isEnd: isEnd,\n          isMid: isMid,\n          isVisited: isVisited,\n          isVisited2: isVisited2,\n          isShortest: isShortest,\n          mouseIsPressed: mouseIsPressed,\n          buttonPressed: buttonPressed,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 216,\n            columnNumber: 21\n          }\n        });\n      }));\n    })));\n  }\n\n}\n\nconst initialiseGrid = () => {\n  let grid = [];\n\n  for (let i = 0; i < N; i++) {\n    let curRow = [];\n\n    for (let j = 0; j < M; j++) {\n      curRow.push(createNode(i, j));\n    }\n\n    grid.push(curRow);\n  }\n\n  return grid;\n}; //return a singular node\n\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isEnd: row === END_NODE_ROW && col === END_NODE_COL,\n    isMid: false,\n    distance: 1000000000,\n    //unable to use Infinity here, cos deep copy does not work with infinity\n    isVisited: false,\n    isVisited2: false,\n    isWall: false,\n    isShortest: false,\n    previousNode: null,\n    src: 0\n  };\n};\n\nconst add_wall_to_grid = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isMid || node.isEnd || node.isStart) return;\n  document.getElementById(`node-${node.row}-${node.col}`).className = \"node node_wall_add\";\n  node.isWall = true;\n};\n\nconst del_wall_from_grid = (grid, row, col) => {\n  const node = grid[row][col];\n  if (!node.isWall || node.isMid || node.isEnd || node.isStart) return;\n  node.isWall = false;\n  document.getElementById(`node-${node.row}-${node.col}`).className = \"node node_wall_del\";\n};\n\nconst change_start_node = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isMid || node.isEnd) return;\n  const pnode = grid[START_NODE_ROW][START_NODE_COL];\n  pnode.isStart = false;\n  document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = \"node\";\n\n  if (workIsDone === false) {\n    document.getElementById(`node-${row}-${col}`).className = \"node node_start\";\n  } else {\n    document.getElementById(`node-${row}-${col}`).className = \"node node_start node-shortest-path-2\";\n  }\n\n  node.isStart = true;\n  START_NODE_ROW = row;\n  START_NODE_COL = col;\n};\n\nconst change_end_node = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isMid || node.isStart) return;\n  const pnode = grid[END_NODE_ROW][END_NODE_COL];\n  pnode.isEnd = false;\n  document.getElementById(`node-${END_NODE_ROW}-${END_NODE_COL}`).className = \"node\";\n  node.isEnd = true;\n  document.getElementById(`node-${row}-${col}`).className = \"node node_end\";\n  END_NODE_ROW = row;\n  END_NODE_COL = col;\n};\n\nconst change_mid_node = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isStart || node.isEnd) return;\n  const pnode = grid[MID_NODE_ROW][MID_NODE_COL];\n  pnode.isMid = false;\n  document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className = \"node\";\n  node.isMid = true;\n  document.getElementById(`node-${row}-${col}`).className = \"node node_mid\";\n  MID_NODE_ROW = row;\n  MID_NODE_COL = col;\n};\n\nconst add_mid_node = grid => {\n  MID_NODE_ROW = 10;\n  MID_NODE_COL = 30;\n  console.log(\"here\");\n  const node = grid[MID_NODE_ROW][MID_NODE_COL];\n  node.isMid = true;\n  node.isWall = false;\n  document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className = \"node node_mid\";\n};\n\nconst del_mid_node = grid => {\n  const node = grid[MID_NODE_ROW][MID_NODE_COL];\n  node.isMid = false;\n  document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className = \"node\";\n  MID_NODE_ROW = MID_NODE_COL = -1;\n};\n\nconst clear_all = grid => {\n  cur_row = cur_col = -1;\n\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (grid[i][j].isWall) continue;\n\n      if (grid[i][j].isVisited) {\n        grid[i][j].isVisited = false;\n      }\n\n      if (grid[i][j].isVisited2) {\n        grid[i][j].isVisited2 = false;\n      }\n\n      if (grid[i][j].isShortest) {\n        grid[i][j].isShortest = false;\n      }\n\n      document.getElementById(`node-${i}-${j}`).className = \"node\";\n    }\n  }\n};\n\nconst clear_clever = g => {\n  cur_row = cur_col = -1;\n\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      var node = g[i][j];\n      if (node.isWall === true) continue;\n      document.getElementById(`node-${i}-${j}`).className = \"node\";\n      node.row = i;\n      node.col = j;\n      node.isStart = node.row === START_NODE_ROW && node.col === START_NODE_COL;\n      node.isEnd = node.row === END_NODE_ROW && node.col === END_NODE_COL;\n      node.isMid = node.row === MID_NODE_ROW && node.col === MID_NODE_COL;\n      node.isWall = false;\n      node.isVisited = false;\n      node.isVisited2 = false;\n      node.isShortest = false;\n      node.distance = 1000000000;\n      node.previousNode = null;\n      node.src = 0;\n    }\n\n    document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`).className = \"node node_start\";\n    document.getElementById(`node-${END_NODE_ROW}-${END_NODE_COL}`).className = \"node node_end\";\n\n    if (MID_NODE_ROW !== -1) {\n      document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className = \"node node_mid\";\n    }\n  }\n};\n\nconst animateShortestPath = (state_grid, nodesInShortestPathOrder, type) => {\n  //this variable is used to check in which index mid node occurs, so that we can change colors\n  let m = 100000000;\n\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    const node = nodesInShortestPathOrder[i];\n    if (i === 1) continue;\n\n    if (MID_NODE_ROW !== -1 && node.row === MID_NODE_ROW && node.col === MID_NODE_COL) {\n      m = i;\n      break;\n    }\n  } //animator code begins here\n\n\n  if (type === 0) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const orig_node = state_grid[node.row][node.col];\n        orig_node.isShortest = orig_node.isVisited = true;\n        let value = \"\";\n\n        if (i >= m) {\n          value = \"node-shortest-path-2\";\n        } else {\n          value = \"node-shortest-path\";\n        }\n\n        if (node.isStart) {\n          value += \" node_start\";\n        } else if (node.isMid) {\n          value += \" node_mid\";\n        } else if (node.isEnd) {\n          value += \" node_end\";\n        }\n\n        document.getElementById(`node-${node.row}-${node.col}`).className = `node ${value}`;\n      }, 20 * i);\n    }\n  } else {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      const node = nodesInShortestPathOrder[i];\n      const orig_node = state_grid[node.row][node.col];\n      orig_node.isShortest = orig_node.isVisited = true;\n\n      if (node.isStart) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node_start node-shortest-path_f\";\n      } else if (node.isMid) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node_mid node-shortest-path_f\";\n      } else if (node.isEnd) {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node_end node-shortest-path_f\";\n      } else {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path_f\";\n      }\n    }\n  }\n};\n\nconst animateAlgorithm = (state_grid, visitedNodesInOrder, nodesInShortestPathOrder, type) => {\n  //this variable is used to check in which index mid node occurs, so that we can change colors\n  let m = 10000000;\n\n  for (let i = 0; i < visitedNodesInOrder.length; i++) {\n    const node = visitedNodesInOrder[i];\n    if (i === 1) continue;\n\n    if (MID_NODE_ROW !== -1 && node.row === MID_NODE_ROW && node.col === MID_NODE_COL) {\n      m = i;\n      break;\n    }\n  } //animator code begins here\n  //  \n\n\n  if (type === 0) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // use to color the final path, yellow in the end\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(state_grid, nodesInShortestPathOrder, type);\n        }, 10 * i);\n        return;\n      } //yellow blinker to indicate current position\n\n\n      const node = visitedNodesInOrder[i];\n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node_current\";\n      }, 10 * i - 15);\n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node\";\n      }, 10 * i - 5); //condition to check if I have to change color\n\n      let value = \"\";\n\n      if (i >= m) {\n        value = \"node_vis_2\";\n      } else {\n        value = \"node_vis\";\n      }\n\n      if (node.isStart) {\n        value += \" node_start\";\n      } else if (node.isMid) {\n        value += \" node_mid\";\n      } else if (node.isEnd) {\n        value += \" node_end\";\n      } //used to color the visited grids in order\n\n\n      setTimeout(() => {\n        const orig_node = state_grid[node.row][node.col];\n        orig_node.isVisited = true;\n        if (node.isStart === true) orig_node.isStart = true;\n        document.getElementById(`node-${node.row}-${node.col}`).className = `node ${value}`;\n      }, 10 * i);\n    }\n  } else {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        animateShortestPath(state_grid, nodesInShortestPathOrder, type);\n        return;\n      }\n\n      const node = visitedNodesInOrder[i];\n      const orig_node = state_grid[node.row][node.col];\n      let value = \"\";\n\n      if (i >= m) {\n        value = \"node_vis_f_2\";\n        orig_node.isVisited2 = true;\n      } else {\n        value = \"node_vis_f\";\n        orig_node.isVisited = true;\n      }\n\n      if (node.isStart) {\n        value += \" node_start\";\n      } else if (node.isMid) {\n        value += \" node_mid\";\n      } else if (node.isEnd) {\n        value += \" node_end\";\n      }\n\n      document.getElementById(`node-${node.row}-${node.col}`).className = `node ${value}`;\n    }\n  }\n};","map":{"version":3,"sources":["/home/jagruth/Documents/path finding/src/App.js"],"names":["React","constants","NavBar","Node","solve_algorithm","START_NODE_ROW","START_NODE_COL","END_NODE_ROW","END_NODE_COL","MID_NODE_ROW","MID_NODE_COL","N","M","cur_row","cur_col","algo","buttonPressed","NONE","workIsDone","App","Component","constructor","props","do_mouse_work","state_grid","row","col","console","log","ADD_WALL","add_wall_to_grid","DEL_WALL","del_wall_from_grid","START","change_start_node","END","change_end_node","MID","change_mid_node","visualizeAlgorithm","handleMouseDown","setState","mouseIsPressed","state","grid","isStart","isEnd","isMid","isWall","handleMouseEnter","handleMouseUp","handleChoice","ch","ADD_MID","add_mid_node","DEL_MID","del_mid_node","handleAlgorithm","end_row","end_col","algo_type","type","clear_all","clear_clever","ret","visitedNodesInOrder","nodesInShortestPathOrder","animateAlgorithm","clearBoard","g","i","j","node","document","getElementById","className","isVisited","isVisited2","isShortest","distance","previousNode","src","componentDidMount","initialiseGrid","render","map","rowIdx","nodeIdx","handleMouseClick","curRow","push","createNode","pnode","animateShortestPath","m","length","setTimeout","orig_node","value"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport \"./App.css\";\nimport * as constants from \"./Constants\";\nimport NavBar from \"./Components/NavBar/NavBar\";\nimport Node from \"./Components/Node/Node\";\nimport { solve_algorithm } from \"./Algorithm/RootCaller\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nlet START_NODE_ROW = 12;\nlet START_NODE_COL = 30;\nlet END_NODE_ROW = 12;\nlet END_NODE_COL = 40;\nlet MID_NODE_ROW = -1;\nlet MID_NODE_COL = -1;\nconst N = 27;\nconst M = 75;\nlet cur_row = -1;\nlet cur_col = -1;\nlet algo = \"\";\nvar buttonPressed = constants.NONE;\nvar workIsDone = false;\n\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n    };\n  }\n\n  do_mouse_work = (state_grid, row, col) => {\n    console.log(buttonPressed);\n    switch (buttonPressed) {\n      case constants.ADD_WALL: {\n        add_wall_to_grid(state_grid, row, col);\n        break;\n      }\n      case constants.DEL_WALL: {\n        del_wall_from_grid(state_grid, row, col);\n        break;\n      }\n\n      case constants.START: {\n        console.log(\"ehere as well\");\n        change_start_node(state_grid, row, col);\n        break;\n      }\n      case constants.END: {\n        change_end_node(state_grid, row, col);\n        break;\n      }\n      case constants.MID: {\n        change_mid_node(state_grid, row, col);\n        break;\n      }\n      default:\n        break;\n    }\n\n    if (workIsDone === true) {\n      console.log(\"me\");\n      //if (this.state.grid[row][col].isWall) return;\n      this.visualizeAlgorithm(1, row, col, algo);\n    }\n  };\n\n  handleMouseDown = (row, col) => {\n    //if (row === cur_row && col === cur_col) return;\n\n    this.setState({ mouseIsPressed: true });\n\n    if (this.state.grid[row][col].isStart) {\n      buttonPressed = constants.START;\n    } else if (this.state.grid[row][col].isEnd) {\n      buttonPressed = constants.END;\n    } else if (this.state.grid[row][col].isMid) {\n      buttonPressed = constants.MID;\n    } else if (this.state.grid[row][col].isWall) {\n      buttonPressed = constants.DEL_WALL;\n    } else {\n      buttonPressed = constants.ADD_WALL;\n    }\n    console.log(buttonPressed);\n    this.do_mouse_work(this.state.grid, row, col);\n\n    cur_row = row;\n    cur_col = col;\n  };\n\n  handleMouseEnter = (row, col) => {\n    //if (row === cur_row && col === cur_col) return;\n    if (!this.state.mouseIsPressed) return;\n\n    this.do_mouse_work(this.state.grid, row, col);\n\n    cur_row = row;\n    cur_col = col;\n  };\n\n  handleMouseUp = () => {\n    this.setState({ mouseIsPressed: false });\n  };\n\n  handleChoice = (ch) => {\n    if (buttonPressed === ch) buttonPressed = constants.NONE;\n    else buttonPressed = ch;\n    if (buttonPressed === constants.ADD_MID) add_mid_node(this.state.grid);\n    else if (buttonPressed === constants.DEL_MID) del_mid_node(this.state.grid);\n  };\n\n  handleAlgorithm = (end_row, end_col, algo_type) => {\n    return solve_algorithm(this.state.grid,\n      START_NODE_ROW,\n      START_NODE_COL,\n      END_NODE_ROW,\n      END_NODE_COL,\n      MID_NODE_ROW,\n      MID_NODE_COL,\n      algo_type);\n  };\n\n  visualizeAlgorithm = (type, row, col, algo_type) => {\n    workIsDone = true;\n    algo = algo_type;\n    if (type === 1) clear_all(this.state.grid);\n    else clear_clever(this.state.grid);\n    const ret = this.handleAlgorithm(row, col, algo);\n    const visitedNodesInOrder = ret[0];\n    const nodesInShortestPathOrder = ret[1];\n    animateAlgorithm(\n      this.state.grid,\n      visitedNodesInOrder,\n      nodesInShortestPathOrder,\n      type\n    );\n    //if (buttonPressed !== constants.DONE) buttonPressed = constants.DONE;\n  };\n\n\n  clearBoard = () => {\n    const g = this.state.grid;\n\n    START_NODE_ROW = 1;\n    START_NODE_COL = 30;\n    END_NODE_ROW = 12;\n    END_NODE_COL = 40;\n    MID_NODE_ROW = MID_NODE_COL = cur_row = cur_col = -1;\n\n    buttonPressed = constants.NONE;\n    workIsDone = false;\n    this.setState({ mouseIsPressed: false });\n    for (let i = 0; i < N; i++) {\n      for (let j = 0; j < M; j++) {\n        var node = g[i][j];\n\n        document.getElementById(`node-${i}-${j}`).className = \"node\";\n        node.row = i;\n        node.col = j;\n        node.isStart =\n        node.row === START_NODE_ROW && node.col === START_NODE_COL;\n        node.isEnd = node.row === END_NODE_ROW && node.col === END_NODE_COL;\n        node.isMid = false;\n        node.isWall = false;\n        node.isVisited = false;\n        node.isVisited2 = false;\n        node.isShortest = false;\n        node.distance = 1000000000;\n        node.previousNode = null;\n        node.src = 0;\n      }\n      document.getElementById(\n        `node-${START_NODE_ROW}-${START_NODE_COL}`\n      ).className = \"node node_start\";\n      document.getElementById(\n        `node-${END_NODE_ROW}-${END_NODE_COL}`\n      ).className = \"node node_end\";\n    }\n    this.setState({ grid: g });\n  };\n\n  componentDidMount() {\n    const g = initialiseGrid();\n    this.setState({ grid: g });\n  }\n\n  render() {\n    const { grid, mouseIsPressed, buttonPressed } = this.state;\n    return (\n      <div>\n        <NavBar\n          clearBoard={this.clearBoard}\n          handleChoice={this.handleChoice}\n          visualizeAlgorithm={this.visualizeAlgorithm}\n          end_node_row={END_NODE_ROW}\n          end_node_col={END_NODE_COL}\n        />\n\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const {\n                    row,\n                    col,\n                    isEnd,\n                    isStart,\n                    isWall,\n                    isVisited,\n                    isVisited2,\n                    isMid,\n                    isShortest,\n                  } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\n                      onMouseEnter={(row, col) =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      onMouseClick={(row, col) =>\n                        this.handleMouseClick(row, col)\n                      }\n                      row={row}\n                      col={col}\n                      isWall={isWall}\n                      isStart={isStart}\n                      isEnd={isEnd}\n                      isMid={isMid}\n                      isVisited={isVisited}\n                      isVisited2={isVisited2}\n                      isShortest={isShortest}\n                      mouseIsPressed={mouseIsPressed}\n                      buttonPressed={buttonPressed}\n                    ></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n\nconst initialiseGrid = () => {\n  let grid = [];\n  for (let i = 0; i < N; i++) {\n    let curRow = [];\n    for (let j = 0; j < M; j++) {\n      curRow.push(createNode(i, j));\n    }\n    grid.push(curRow);\n  }\n  return grid;\n};\n\n//return a singular node\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\n    isEnd: row === END_NODE_ROW && col === END_NODE_COL,\n    isMid: false,\n    distance: 1000000000, //unable to use Infinity here, cos deep copy does not work with infinity\n    isVisited: false,\n    isVisited2: false,\n    isWall: false,\n    isShortest: false,\n    previousNode: null,\n    src: 0,\n  };\n};\n\nconst add_wall_to_grid = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isMid || node.isEnd || node.isStart) return;\n  document.getElementById(`node-${node.row}-${node.col}`).className =\n    \"node node_wall_add\";\n  node.isWall = true;\n};\n\nconst del_wall_from_grid = (grid, row, col) => {\n  const node = grid[row][col];\n  if (!node.isWall || node.isMid || node.isEnd || node.isStart) return;\n  node.isWall = false;\n  document.getElementById(`node-${node.row}-${node.col}`).className =\n    \"node node_wall_del\";\n};\n\nconst change_start_node = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isMid || node.isEnd) return;\n  const pnode = grid[START_NODE_ROW][START_NODE_COL];\n  pnode.isStart = false;\n  document.getElementById(\n    `node-${START_NODE_ROW}-${START_NODE_COL}`\n  ).className = \"node\";\n  if (workIsDone === false) {\n    document.getElementById(`node-${row}-${col}`).className = \"node node_start\";\n  } else {\n    document.getElementById(`node-${row}-${col}`).className =\n      \"node node_start node-shortest-path-2\";\n  }\n  node.isStart = true;\n  START_NODE_ROW = row;\n  START_NODE_COL = col;\n};\n\nconst change_end_node = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isMid || node.isStart) return;\n  const pnode = grid[END_NODE_ROW][END_NODE_COL];\n  pnode.isEnd = false;\n  document.getElementById(`node-${END_NODE_ROW}-${END_NODE_COL}`).className =\n    \"node\";\n  node.isEnd = true;\n  document.getElementById(`node-${row}-${col}`).className = \"node node_end\";\n  END_NODE_ROW = row;\n  END_NODE_COL = col;\n};\n\nconst change_mid_node = (grid, row, col) => {\n  const node = grid[row][col];\n  if (node.isWall || node.isStart || node.isEnd) return;\n  const pnode = grid[MID_NODE_ROW][MID_NODE_COL];\n  pnode.isMid = false;\n  document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className =\n    \"node\";\n  node.isMid = true;\n  document.getElementById(`node-${row}-${col}`).className = \"node node_mid\";\n  MID_NODE_ROW = row;\n  MID_NODE_COL = col;\n};\n\nconst add_mid_node = (grid) => {\n  MID_NODE_ROW = 10;\n  MID_NODE_COL = 30;\n  console.log(\"here\");\n  const node = grid[MID_NODE_ROW][MID_NODE_COL];\n  node.isMid = true;\n  node.isWall = false;\n  document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className =\n    \"node node_mid\";\n};\n\nconst del_mid_node = (grid) => {\n  const node = grid[MID_NODE_ROW][MID_NODE_COL];\n  node.isMid = false;\n  document.getElementById(`node-${MID_NODE_ROW}-${MID_NODE_COL}`).className =\n    \"node\";\n  MID_NODE_ROW = MID_NODE_COL = -1;\n};\n\nconst clear_all = (grid) => {\n  cur_row = cur_col = -1;\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      if (grid[i][j].isWall) continue;\n      if (grid[i][j].isVisited) {\n        grid[i][j].isVisited = false;\n      }\n      if (grid[i][j].isVisited2) {\n        grid[i][j].isVisited2 = false;\n      }\n      if (grid[i][j].isShortest) {\n        grid[i][j].isShortest = false;\n      }\n      document.getElementById(`node-${i}-${j}`).className = \"node\";\n    }\n  }\n};\n\nconst clear_clever = (g) => {\n  cur_row = cur_col = -1;\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < M; j++) {\n      var node = g[i][j];\n      if (node.isWall === true) continue;\n      document.getElementById(`node-${i}-${j}`).className = \"node\";\n      node.row = i;\n      node.col = j;\n      node.isStart = node.row === START_NODE_ROW && node.col === START_NODE_COL;\n      node.isEnd = node.row === END_NODE_ROW && node.col === END_NODE_COL;\n      node.isMid = node.row === MID_NODE_ROW && node.col === MID_NODE_COL;\n      node.isWall = false;\n      node.isVisited = false;\n      node.isVisited2 = false;\n      node.isShortest = false;\n      node.distance = 1000000000;\n      node.previousNode = null;\n      node.src = 0;\n    }\n    document.getElementById(\n      `node-${START_NODE_ROW}-${START_NODE_COL}`\n    ).className = \"node node_start\";\n    document.getElementById(`node-${END_NODE_ROW}-${END_NODE_COL}`).className =\n      \"node node_end\";\n    if (MID_NODE_ROW !== -1) {\n      document.getElementById(\n        `node-${MID_NODE_ROW}-${MID_NODE_COL}`\n      ).className = \"node node_mid\";\n    }\n  }\n};\n\nconst animateShortestPath = (state_grid, nodesInShortestPathOrder, type) => {\n  //this variable is used to check in which index mid node occurs, so that we can change colors\n  let m = 100000000;\n  for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n    const node = nodesInShortestPathOrder[i];\n    if (i === 1) continue;\n    if (\n      MID_NODE_ROW !== -1 &&\n      node.row === MID_NODE_ROW &&\n      node.col === MID_NODE_COL\n    ) {\n      m = i;\n      break;\n    }\n  }\n\n  //animator code begins here\n  if (type === 0) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const orig_node = state_grid[node.row][node.col];\n        orig_node.isShortest = orig_node.isVisited = true;\n\n        let value = \"\";\n        if (i >= m) {\n          value = \"node-shortest-path-2\";\n        } else {\n          value = \"node-shortest-path\";\n        }\n        if (node.isStart) {\n          value += \" node_start\";\n        } else if (node.isMid) {\n          value += \" node_mid\";\n        } else if (node.isEnd) {\n          value += \" node_end\";\n        }\n        document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className = `node ${value}`;\n      }, 20 * i);\n    }\n  } else {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      const node = nodesInShortestPathOrder[i];\n      const orig_node = state_grid[node.row][node.col];\n      orig_node.isShortest = orig_node.isVisited = true;\n      if (node.isStart) {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node_start node-shortest-path_f\";\n      } else if (node.isMid) {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node_mid node-shortest-path_f\";\n      } else if (node.isEnd) {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node_end node-shortest-path_f\";\n      } else {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path_f\";\n      }\n    }\n  }\n};\n\nconst animateAlgorithm = (\n  state_grid,\n  visitedNodesInOrder,\n  nodesInShortestPathOrder,\n  type\n) => {\n  //this variable is used to check in which index mid node occurs, so that we can change colors\n  let m = 10000000;\n  for (let i = 0; i < visitedNodesInOrder.length; i++) {\n    const node = visitedNodesInOrder[i];\n    if (i === 1) continue;\n    if (\n      MID_NODE_ROW !== -1 &&\n      node.row === MID_NODE_ROW &&\n      node.col === MID_NODE_COL\n    ) {\n      m = i;\n      break;\n    }\n  }\n\n  //animator code begins here\n//  \n  if (type === 0) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      // use to color the final path, yellow in the end\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(state_grid, nodesInShortestPathOrder, type);\n        }, 10 * i);\n        return;\n      }\n\n      //yellow blinker to indicate current position\n      const node = visitedNodesInOrder[i];\n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node_current\";\n      }, 10 * i - 15);\n      \n      setTimeout(() => {\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node\";\n      }, 10 * i - 5);\n\n      //condition to check if I have to change color\n      let value = \"\";\n      if (i >= m) {\n        value = \"node_vis_2\";\n      } else {\n        value = \"node_vis\";\n      }\n\n      if (node.isStart) {\n        value += \" node_start\";\n      } else if (node.isMid) {\n        value += \" node_mid\";\n      } else if (node.isEnd) {\n        value += \" node_end\";\n      }\n\n      //used to color the visited grids in order\n      setTimeout(() => {\n        const orig_node = state_grid[node.row][node.col];\n        orig_node.isVisited = true;\n        if (node.isStart === true) orig_node.isStart = true;\n        document.getElementById(\n          `node-${node.row}-${node.col}`\n        ).className = `node ${value}`;\n      }, 10 * i);\n    }\n  } else {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        animateShortestPath(state_grid, nodesInShortestPathOrder, type);\n        return;\n      }\n\n      const node = visitedNodesInOrder[i];\n      const orig_node = state_grid[node.row][node.col];\n      let value = \"\";\n      if (i >= m) {\n        value = \"node_vis_f_2\";\n        orig_node.isVisited2 = true;\n      } else {\n        value = \"node_vis_f\";\n        orig_node.isVisited = true;\n      }\n\n      if (node.isStart) {\n        value += \" node_start\";\n      } else if (node.isMid) {\n        value += \" node_mid\";\n      } else if (node.isEnd) {\n        value += \" node_end\";\n      }\n      document.getElementById(\n        `node-${node.row}-${node.col}`\n      ).className = `node ${value}`;\n    }\n  }\n};\n\n"]},"metadata":{},"sourceType":"module"}